/*
EVE Stellar Information (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2020-01-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

// UserInterfaceAPIService UserInterfaceAPI service
type UserInterfaceAPIService service

type ApiPostUiAutopilotWaypointRequest struct {
	ctx                 context.Context
	ApiService          *UserInterfaceAPIService
	addToBeginning      *bool
	clearOtherWaypoints *bool
	destinationId       *int64
	xCompatibilityDate  *string
	acceptLanguage      *string
	ifNoneMatch         *string
	xTenant             *string
}

func (r ApiPostUiAutopilotWaypointRequest) AddToBeginning(addToBeginning bool) ApiPostUiAutopilotWaypointRequest {
	r.addToBeginning = &addToBeginning
	return r
}

func (r ApiPostUiAutopilotWaypointRequest) ClearOtherWaypoints(clearOtherWaypoints bool) ApiPostUiAutopilotWaypointRequest {
	r.clearOtherWaypoints = &clearOtherWaypoints
	return r
}

func (r ApiPostUiAutopilotWaypointRequest) DestinationId(destinationId int64) ApiPostUiAutopilotWaypointRequest {
	r.destinationId = &destinationId
	return r
}

// The compatibility date for the request.
func (r ApiPostUiAutopilotWaypointRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostUiAutopilotWaypointRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response. Defaults to &#39;en&#39;.
func (r ApiPostUiAutopilotWaypointRequest) AcceptLanguage(acceptLanguage string) ApiPostUiAutopilotWaypointRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostUiAutopilotWaypointRequest) IfNoneMatch(ifNoneMatch string) ApiPostUiAutopilotWaypointRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request. Defaults to &#39;tranquility&#39;.
func (r ApiPostUiAutopilotWaypointRequest) XTenant(xTenant string) ApiPostUiAutopilotWaypointRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostUiAutopilotWaypointRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.PostUiAutopilotWaypointExecute(r)
}

/*
PostUiAutopilotWaypoint Set Autopilot Waypoint

Set a solar system as autopilot waypoint

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUiAutopilotWaypointRequest
*/
func (a *UserInterfaceAPIService) PostUiAutopilotWaypoint(ctx context.Context) ApiPostUiAutopilotWaypointRequest {
	return ApiPostUiAutopilotWaypointRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *UserInterfaceAPIService) PostUiAutopilotWaypointExecute(r ApiPostUiAutopilotWaypointRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserInterfaceAPIService.PostUiAutopilotWaypoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ui/autopilot/waypoint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addToBeginning == nil {
		return localVarReturnValue, nil, reportError("addToBeginning is required and must be specified")
	}
	if r.clearOtherWaypoints == nil {
		return localVarReturnValue, nil, reportError("clearOtherWaypoints is required and must be specified")
	}
	if r.destinationId == nil {
		return localVarReturnValue, nil, reportError("destinationId is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "add_to_beginning", r.addToBeginning, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "clear_other_waypoints", r.clearOtherWaypoints, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "destination_id", r.destinationId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUiOpenwindowContractRequest struct {
	ctx                context.Context
	ApiService         *UserInterfaceAPIService
	contractId         *int64
	xCompatibilityDate *string
	acceptLanguage     *string
	ifNoneMatch        *string
	xTenant            *string
}

func (r ApiPostUiOpenwindowContractRequest) ContractId(contractId int64) ApiPostUiOpenwindowContractRequest {
	r.contractId = &contractId
	return r
}

// The compatibility date for the request.
func (r ApiPostUiOpenwindowContractRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostUiOpenwindowContractRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response. Defaults to &#39;en&#39;.
func (r ApiPostUiOpenwindowContractRequest) AcceptLanguage(acceptLanguage string) ApiPostUiOpenwindowContractRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostUiOpenwindowContractRequest) IfNoneMatch(ifNoneMatch string) ApiPostUiOpenwindowContractRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request. Defaults to &#39;tranquility&#39;.
func (r ApiPostUiOpenwindowContractRequest) XTenant(xTenant string) ApiPostUiOpenwindowContractRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostUiOpenwindowContractRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.PostUiOpenwindowContractExecute(r)
}

/*
PostUiOpenwindowContract Open Contract Window

Open the contract window inside the client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUiOpenwindowContractRequest
*/
func (a *UserInterfaceAPIService) PostUiOpenwindowContract(ctx context.Context) ApiPostUiOpenwindowContractRequest {
	return ApiPostUiOpenwindowContractRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *UserInterfaceAPIService) PostUiOpenwindowContractExecute(r ApiPostUiOpenwindowContractRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserInterfaceAPIService.PostUiOpenwindowContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ui/openwindow/contract"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contractId == nil {
		return localVarReturnValue, nil, reportError("contractId is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "contract_id", r.contractId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUiOpenwindowInformationRequest struct {
	ctx                context.Context
	ApiService         *UserInterfaceAPIService
	targetId           *int64
	xCompatibilityDate *string
	acceptLanguage     *string
	ifNoneMatch        *string
	xTenant            *string
}

func (r ApiPostUiOpenwindowInformationRequest) TargetId(targetId int64) ApiPostUiOpenwindowInformationRequest {
	r.targetId = &targetId
	return r
}

// The compatibility date for the request.
func (r ApiPostUiOpenwindowInformationRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostUiOpenwindowInformationRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response. Defaults to &#39;en&#39;.
func (r ApiPostUiOpenwindowInformationRequest) AcceptLanguage(acceptLanguage string) ApiPostUiOpenwindowInformationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostUiOpenwindowInformationRequest) IfNoneMatch(ifNoneMatch string) ApiPostUiOpenwindowInformationRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request. Defaults to &#39;tranquility&#39;.
func (r ApiPostUiOpenwindowInformationRequest) XTenant(xTenant string) ApiPostUiOpenwindowInformationRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostUiOpenwindowInformationRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.PostUiOpenwindowInformationExecute(r)
}

/*
PostUiOpenwindowInformation Open Information Window

Open the information window for a character, corporation or alliance inside the client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUiOpenwindowInformationRequest
*/
func (a *UserInterfaceAPIService) PostUiOpenwindowInformation(ctx context.Context) ApiPostUiOpenwindowInformationRequest {
	return ApiPostUiOpenwindowInformationRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *UserInterfaceAPIService) PostUiOpenwindowInformationExecute(r ApiPostUiOpenwindowInformationRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserInterfaceAPIService.PostUiOpenwindowInformation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ui/openwindow/information"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.targetId == nil {
		return localVarReturnValue, nil, reportError("targetId is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "target_id", r.targetId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUiOpenwindowMarketdetailsRequest struct {
	ctx                context.Context
	ApiService         *UserInterfaceAPIService
	typeId             *int64
	xCompatibilityDate *string
	acceptLanguage     *string
	ifNoneMatch        *string
	xTenant            *string
}

func (r ApiPostUiOpenwindowMarketdetailsRequest) TypeId(typeId int64) ApiPostUiOpenwindowMarketdetailsRequest {
	r.typeId = &typeId
	return r
}

// The compatibility date for the request.
func (r ApiPostUiOpenwindowMarketdetailsRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostUiOpenwindowMarketdetailsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response. Defaults to &#39;en&#39;.
func (r ApiPostUiOpenwindowMarketdetailsRequest) AcceptLanguage(acceptLanguage string) ApiPostUiOpenwindowMarketdetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostUiOpenwindowMarketdetailsRequest) IfNoneMatch(ifNoneMatch string) ApiPostUiOpenwindowMarketdetailsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request. Defaults to &#39;tranquility&#39;.
func (r ApiPostUiOpenwindowMarketdetailsRequest) XTenant(xTenant string) ApiPostUiOpenwindowMarketdetailsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostUiOpenwindowMarketdetailsRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.PostUiOpenwindowMarketdetailsExecute(r)
}

/*
PostUiOpenwindowMarketdetails Open Market Details

Open the market details window for a specific typeID inside the client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUiOpenwindowMarketdetailsRequest
*/
func (a *UserInterfaceAPIService) PostUiOpenwindowMarketdetails(ctx context.Context) ApiPostUiOpenwindowMarketdetailsRequest {
	return ApiPostUiOpenwindowMarketdetailsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *UserInterfaceAPIService) PostUiOpenwindowMarketdetailsExecute(r ApiPostUiOpenwindowMarketdetailsRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserInterfaceAPIService.PostUiOpenwindowMarketdetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ui/openwindow/marketdetails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.typeId == nil {
		return localVarReturnValue, nil, reportError("typeId is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type_id", r.typeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUiOpenwindowNewmailRequest struct {
	ctx                            context.Context
	ApiService                     *UserInterfaceAPIService
	xCompatibilityDate             *string
	acceptLanguage                 *string
	ifNoneMatch                    *string
	xTenant                        *string
	postUiOpenwindowNewmailRequest *PostUiOpenwindowNewmailRequest
}

// The compatibility date for the request.
func (r ApiPostUiOpenwindowNewmailRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostUiOpenwindowNewmailRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response. Defaults to &#39;en&#39;.
func (r ApiPostUiOpenwindowNewmailRequest) AcceptLanguage(acceptLanguage string) ApiPostUiOpenwindowNewmailRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostUiOpenwindowNewmailRequest) IfNoneMatch(ifNoneMatch string) ApiPostUiOpenwindowNewmailRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request. Defaults to &#39;tranquility&#39;.
func (r ApiPostUiOpenwindowNewmailRequest) XTenant(xTenant string) ApiPostUiOpenwindowNewmailRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostUiOpenwindowNewmailRequest) PostUiOpenwindowNewmailRequest(postUiOpenwindowNewmailRequest PostUiOpenwindowNewmailRequest) ApiPostUiOpenwindowNewmailRequest {
	r.postUiOpenwindowNewmailRequest = &postUiOpenwindowNewmailRequest
	return r
}

func (r ApiPostUiOpenwindowNewmailRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.PostUiOpenwindowNewmailExecute(r)
}

/*
PostUiOpenwindowNewmail Open New Mail Window

Open the New Mail window, according to settings from the request if applicable

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUiOpenwindowNewmailRequest
*/
func (a *UserInterfaceAPIService) PostUiOpenwindowNewmail(ctx context.Context) ApiPostUiOpenwindowNewmailRequest {
	return ApiPostUiOpenwindowNewmailRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *UserInterfaceAPIService) PostUiOpenwindowNewmailExecute(r ApiPostUiOpenwindowNewmailRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserInterfaceAPIService.PostUiOpenwindowNewmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ui/openwindow/newmail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.postUiOpenwindowNewmailRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
