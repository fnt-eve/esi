/*
EVE Stellar Information (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2020-01-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// AssetsAPIService AssetsAPI service
type AssetsAPIService service

type ApiGetCharactersCharacterIdAssetsRequest struct {
	ctx                context.Context
	ApiService         *AssetsAPIService
	characterId        int64
	xCompatibilityDate *string
	page               *int32
	acceptLanguage     *string
	ifNoneMatch        *string
	xTenant            *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdAssetsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdAssetsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCharactersCharacterIdAssetsRequest) Page(page int32) ApiGetCharactersCharacterIdAssetsRequest {
	r.page = &page
	return r
}

// The language to use for the response. Defaults to &#39;en&#39;.
func (r ApiGetCharactersCharacterIdAssetsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdAssetsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdAssetsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdAssetsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request. Defaults to &#39;tranquility&#39;.
func (r ApiGetCharactersCharacterIdAssetsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdAssetsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdAssetsRequest) Execute() ([]CharactersCharacterIdAssetsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdAssetsExecute(r)
}

/*
GetCharactersCharacterIdAssets Get character assets

Return a list of the characters assets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdAssetsRequest
*/
func (a *AssetsAPIService) GetCharactersCharacterIdAssets(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdAssetsRequest {
	return ApiGetCharactersCharacterIdAssetsRequest{
		ApiService:  a,
		ctx:         ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//
//	@return []CharactersCharacterIdAssetsGetInner
func (a *AssetsAPIService) GetCharactersCharacterIdAssetsExecute(r ApiGetCharactersCharacterIdAssetsRequest) ([]CharactersCharacterIdAssetsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CharactersCharacterIdAssetsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.GetCharactersCharacterIdAssets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/assets"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdAssetsRequest struct {
	ctx                context.Context
	ApiService         *AssetsAPIService
	corporationId      int64
	xCompatibilityDate *string
	page               *int32
	acceptLanguage     *string
	ifNoneMatch        *string
	xTenant            *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdAssetsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdAssetsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdAssetsRequest) Page(page int32) ApiGetCorporationsCorporationIdAssetsRequest {
	r.page = &page
	return r
}

// The language to use for the response. Defaults to &#39;en&#39;.
func (r ApiGetCorporationsCorporationIdAssetsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdAssetsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdAssetsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdAssetsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request. Defaults to &#39;tranquility&#39;.
func (r ApiGetCorporationsCorporationIdAssetsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdAssetsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdAssetsRequest) Execute() ([]CorporationsCorporationIdAssetsGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdAssetsExecute(r)
}

/*
GetCorporationsCorporationIdAssets Get corporation assets

# Return a list of the corporation assets

Requires one of the following EVE corporation role(s): Director

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdAssetsRequest
*/
func (a *AssetsAPIService) GetCorporationsCorporationIdAssets(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdAssetsRequest {
	return ApiGetCorporationsCorporationIdAssetsRequest{
		ApiService:    a,
		ctx:           ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//
//	@return []CorporationsCorporationIdAssetsGetInner
func (a *AssetsAPIService) GetCorporationsCorporationIdAssetsExecute(r ApiGetCorporationsCorporationIdAssetsRequest) ([]CorporationsCorporationIdAssetsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CorporationsCorporationIdAssetsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.GetCorporationsCorporationIdAssets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/assets"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCharactersCharacterIdAssetsLocationsRequest struct {
	ctx                context.Context
	ApiService         *AssetsAPIService
	characterId        int64
	xCompatibilityDate *string
	acceptLanguage     *string
	ifNoneMatch        *string
	xTenant            *string
	requestBody        *[]int64
}

// The compatibility date for the request.
func (r ApiPostCharactersCharacterIdAssetsLocationsRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostCharactersCharacterIdAssetsLocationsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response. Defaults to &#39;en&#39;.
func (r ApiPostCharactersCharacterIdAssetsLocationsRequest) AcceptLanguage(acceptLanguage string) ApiPostCharactersCharacterIdAssetsLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostCharactersCharacterIdAssetsLocationsRequest) IfNoneMatch(ifNoneMatch string) ApiPostCharactersCharacterIdAssetsLocationsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request. Defaults to &#39;tranquility&#39;.
func (r ApiPostCharactersCharacterIdAssetsLocationsRequest) XTenant(xTenant string) ApiPostCharactersCharacterIdAssetsLocationsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostCharactersCharacterIdAssetsLocationsRequest) RequestBody(requestBody []int64) ApiPostCharactersCharacterIdAssetsLocationsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiPostCharactersCharacterIdAssetsLocationsRequest) Execute() ([]CharactersCharacterIdAssetsLocationsPostInner, *http.Response, error) {
	return r.ApiService.PostCharactersCharacterIdAssetsLocationsExecute(r)
}

/*
PostCharactersCharacterIdAssetsLocations Get character asset locations

Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiPostCharactersCharacterIdAssetsLocationsRequest
*/
func (a *AssetsAPIService) PostCharactersCharacterIdAssetsLocations(ctx context.Context, characterId int64) ApiPostCharactersCharacterIdAssetsLocationsRequest {
	return ApiPostCharactersCharacterIdAssetsLocationsRequest{
		ApiService:  a,
		ctx:         ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//
//	@return []CharactersCharacterIdAssetsLocationsPostInner
func (a *AssetsAPIService) PostCharactersCharacterIdAssetsLocationsExecute(r ApiPostCharactersCharacterIdAssetsLocationsRequest) ([]CharactersCharacterIdAssetsLocationsPostInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CharactersCharacterIdAssetsLocationsPostInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.PostCharactersCharacterIdAssetsLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/assets/locations"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCharactersCharacterIdAssetsNamesRequest struct {
	ctx                context.Context
	ApiService         *AssetsAPIService
	characterId        int64
	xCompatibilityDate *string
	acceptLanguage     *string
	ifNoneMatch        *string
	xTenant            *string
	requestBody        *[]int64
}

// The compatibility date for the request.
func (r ApiPostCharactersCharacterIdAssetsNamesRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostCharactersCharacterIdAssetsNamesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response. Defaults to &#39;en&#39;.
func (r ApiPostCharactersCharacterIdAssetsNamesRequest) AcceptLanguage(acceptLanguage string) ApiPostCharactersCharacterIdAssetsNamesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostCharactersCharacterIdAssetsNamesRequest) IfNoneMatch(ifNoneMatch string) ApiPostCharactersCharacterIdAssetsNamesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request. Defaults to &#39;tranquility&#39;.
func (r ApiPostCharactersCharacterIdAssetsNamesRequest) XTenant(xTenant string) ApiPostCharactersCharacterIdAssetsNamesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostCharactersCharacterIdAssetsNamesRequest) RequestBody(requestBody []int64) ApiPostCharactersCharacterIdAssetsNamesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiPostCharactersCharacterIdAssetsNamesRequest) Execute() ([]CharactersCharacterIdAssetsNamesPostInner, *http.Response, error) {
	return r.ApiService.PostCharactersCharacterIdAssetsNamesExecute(r)
}

/*
PostCharactersCharacterIdAssetsNames Get character asset names

Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiPostCharactersCharacterIdAssetsNamesRequest
*/
func (a *AssetsAPIService) PostCharactersCharacterIdAssetsNames(ctx context.Context, characterId int64) ApiPostCharactersCharacterIdAssetsNamesRequest {
	return ApiPostCharactersCharacterIdAssetsNamesRequest{
		ApiService:  a,
		ctx:         ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//
//	@return []CharactersCharacterIdAssetsNamesPostInner
func (a *AssetsAPIService) PostCharactersCharacterIdAssetsNamesExecute(r ApiPostCharactersCharacterIdAssetsNamesRequest) ([]CharactersCharacterIdAssetsNamesPostInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CharactersCharacterIdAssetsNamesPostInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.PostCharactersCharacterIdAssetsNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/assets/names"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCorporationsCorporationIdAssetsLocationsRequest struct {
	ctx                context.Context
	ApiService         *AssetsAPIService
	corporationId      int64
	xCompatibilityDate *string
	acceptLanguage     *string
	ifNoneMatch        *string
	xTenant            *string
	requestBody        *[]int64
}

// The compatibility date for the request.
func (r ApiPostCorporationsCorporationIdAssetsLocationsRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostCorporationsCorporationIdAssetsLocationsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response. Defaults to &#39;en&#39;.
func (r ApiPostCorporationsCorporationIdAssetsLocationsRequest) AcceptLanguage(acceptLanguage string) ApiPostCorporationsCorporationIdAssetsLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostCorporationsCorporationIdAssetsLocationsRequest) IfNoneMatch(ifNoneMatch string) ApiPostCorporationsCorporationIdAssetsLocationsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request. Defaults to &#39;tranquility&#39;.
func (r ApiPostCorporationsCorporationIdAssetsLocationsRequest) XTenant(xTenant string) ApiPostCorporationsCorporationIdAssetsLocationsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostCorporationsCorporationIdAssetsLocationsRequest) RequestBody(requestBody []int64) ApiPostCorporationsCorporationIdAssetsLocationsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiPostCorporationsCorporationIdAssetsLocationsRequest) Execute() ([]CharactersCharacterIdAssetsLocationsPostInner, *http.Response, error) {
	return r.ApiService.PostCorporationsCorporationIdAssetsLocationsExecute(r)
}

/*
PostCorporationsCorporationIdAssetsLocations Get corporation asset locations

Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)

Requires one of the following EVE corporation role(s): Director

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiPostCorporationsCorporationIdAssetsLocationsRequest
*/
func (a *AssetsAPIService) PostCorporationsCorporationIdAssetsLocations(ctx context.Context, corporationId int64) ApiPostCorporationsCorporationIdAssetsLocationsRequest {
	return ApiPostCorporationsCorporationIdAssetsLocationsRequest{
		ApiService:    a,
		ctx:           ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//
//	@return []CharactersCharacterIdAssetsLocationsPostInner
func (a *AssetsAPIService) PostCorporationsCorporationIdAssetsLocationsExecute(r ApiPostCorporationsCorporationIdAssetsLocationsRequest) ([]CharactersCharacterIdAssetsLocationsPostInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CharactersCharacterIdAssetsLocationsPostInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.PostCorporationsCorporationIdAssetsLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/assets/locations"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCorporationsCorporationIdAssetsNamesRequest struct {
	ctx                context.Context
	ApiService         *AssetsAPIService
	corporationId      int64
	xCompatibilityDate *string
	acceptLanguage     *string
	ifNoneMatch        *string
	xTenant            *string
	requestBody        *[]int64
}

// The compatibility date for the request.
func (r ApiPostCorporationsCorporationIdAssetsNamesRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostCorporationsCorporationIdAssetsNamesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response. Defaults to &#39;en&#39;.
func (r ApiPostCorporationsCorporationIdAssetsNamesRequest) AcceptLanguage(acceptLanguage string) ApiPostCorporationsCorporationIdAssetsNamesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostCorporationsCorporationIdAssetsNamesRequest) IfNoneMatch(ifNoneMatch string) ApiPostCorporationsCorporationIdAssetsNamesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request. Defaults to &#39;tranquility&#39;.
func (r ApiPostCorporationsCorporationIdAssetsNamesRequest) XTenant(xTenant string) ApiPostCorporationsCorporationIdAssetsNamesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostCorporationsCorporationIdAssetsNamesRequest) RequestBody(requestBody []int64) ApiPostCorporationsCorporationIdAssetsNamesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiPostCorporationsCorporationIdAssetsNamesRequest) Execute() ([]CharactersCharacterIdAssetsNamesPostInner, *http.Response, error) {
	return r.ApiService.PostCorporationsCorporationIdAssetsNamesExecute(r)
}

/*
PostCorporationsCorporationIdAssetsNames Get corporation asset names

Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships

Requires one of the following EVE corporation role(s): Director

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiPostCorporationsCorporationIdAssetsNamesRequest
*/
func (a *AssetsAPIService) PostCorporationsCorporationIdAssetsNames(ctx context.Context, corporationId int64) ApiPostCorporationsCorporationIdAssetsNamesRequest {
	return ApiPostCorporationsCorporationIdAssetsNamesRequest{
		ApiService:    a,
		ctx:           ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//
//	@return []CharactersCharacterIdAssetsNamesPostInner
func (a *AssetsAPIService) PostCorporationsCorporationIdAssetsNamesExecute(r ApiPostCorporationsCorporationIdAssetsNamesRequest) ([]CharactersCharacterIdAssetsNamesPostInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CharactersCharacterIdAssetsNamesPostInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.PostCorporationsCorporationIdAssetsNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/assets/names"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
